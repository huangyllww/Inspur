//
// Copyright (c) 2006-2019, Intel Corporation
// All rights reserved. This program and the accompanying materials
// are licensed and made available under the terms and conditions of the BSD License
// which accompanies this distribution.  The full text of the license may be found at
// http://opensource.org/licenses/bsd-license.php
//
// THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
// WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
//
// Module Description:
//
//    Boot Maintenance Utility Formset
//

#include "FormsetConfiguration.h"


#define BOOT_FORM_SET


formset
  guid     = FORMSET_GUID_BOOT,
  title    = STRING_TOKEN(FORMSET_TITLE_BOOT),
  help     = STRING_TOKEN(FORMSET_TITLE_BOOT_HELP),
  class    = BYO_FORMSET_CLASS,
  subclass = BYO_FORMSET_SUB_CLASS,

  #define FORM_SET_VARSTORE
  #include <SetupDefinitions.h>
  #undef FORM_SET_VARSTORE

  SYSTEM_PASSWORD_VARSTORE

  form formid = ROOT_FORM_ID,
      title = STRING_TOKEN(FORMSET_TITLE_BOOT);

      LOGIN_TYPE_ADMIN;
      numeric varid = SETUP_DATA.BootTimeout,
        prompt    = STRING_TOKEN(STR_BOOT_TIMEOUT),
        help      = STRING_TOKEN(STR_BOOT_TIMEOUT_HELP),
        minimum   = 1,
        maximum   = 20,
        step      = 1,
        default   = FixedPcdGet8(PcdDefaultBootTimeout),
      endnumeric;

      oneof varid   = SETUP_DATA.Numlock,
        prompt      = STRING_TOKEN(STR_CSM_BOOTUP_NUMLOCK),
        help        = STRING_TOKEN(STR_CSM_BOOTUP_NUMLOCK_HELP),
        option text = STRING_TOKEN(STR_CSM_BOOTUP_NUMLOCK_ON),  value = 1, flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
        option text = STRING_TOKEN(STR_CSM_BOOTUP_NUMLOCK_OFF), value = 0, flags = RESET_REQUIRED;
      endoneof;

      oneof
        varid       = SETUP_DATA.QuietBootMode,
        prompt      = STRING_TOKEN (STR_QUIET_BOOT_MODE),
        help        = STRING_TOKEN (STR_QUIET_BOOT_MODE),
        option text = STRING_TOKEN (STR_QB_NONE),      value = 3, flags = RESET_REQUIRED;        
        option text = STRING_TOKEN (STR_QB_LOGO),      value = 2, flags = RESET_REQUIRED;      
        option text = STRING_TOKEN (STR_QB_INFO),      value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_QB_LOGO_INFO), value = 0, flags = RESET_REQUIRED | DEFAULT;
      endoneof;

      suppressif ideqval SETUP_DATA.QuietBootMode == 2 OR ideqval SETUP_DATA.QuietBootMode == 3;
        numeric varid = SETUP_DATA.WaitToShowPostInfo,
          prompt    = STRING_TOKEN(STR_WAIT_TO_SHOW_POST_INFO),
          help      = STRING_TOKEN(STR_WAIT_TO_SHOW_POST_INFO_HELP),
          minimum   = 0,
          maximum   = 65535,
          step      = 1,
          default   = 0,
        endnumeric;
      endif;

      suppressif ideqval SETUP_DATA.BootModeType == BIOS_BOOT_UEFI_OS;
        oneof varid  = SETUP_DATA.LegacyOpromMessageDis,
          prompt = STRING_TOKEN(STR_OPROM_MESSAGE),
          help = STRING_TOKEN(STR_OPROM_MESSAGE_HELP),
          option text = STRING_TOKEN(STR_ENABLED),  value = 0, flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
          option text = STRING_TOKEN(STR_DISABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

#if FixedPcdGetBool(PcdSetupHasCsmItem)
      oneof varid  = SETUP_DATA.Csm,
        questionid = KEY_VALUE_CSM_CONFIGURATION,
        prompt = STRING_TOKEN(STR_ENABLE_CSM),
        help = STRING_TOKEN(STR_ENABLE_CSM_HELP),
        flags = INTERACTIVE,
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
      endoneof;

      suppressif ideqval SETUP_DATA.Csm == 0;
        oneof varid  = SETUP_DATA.BootModeType,
          prompt = STRING_TOKEN(STR_BOOT_MODE),
          help = STRING_TOKEN(STR_BOOT_MODE_HELP),
          option text = STRING_TOKEN(STR_ALL),         value = BIOS_BOOT_ALL_OS,    flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
          option text = STRING_TOKEN(STR_UEFI_ONLY),   value = BIOS_BOOT_UEFI_OS,   flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_LEGACY_ONLY), value = BIOS_BOOT_LEGACY_OS, flags = RESET_REQUIRED;
        endoneof;
      endif;
      
      suppressif ideqval SETUP_DATA.Csm == 1;
        text
          help   = STRING_TOKEN(STR_NULL_STRING),
          text   = STRING_TOKEN(STR_BOOT_MODE),
          text   = STRING_TOKEN(STR_UEFI_ONLY),
          flags  = 0,
          key    = 0;
      endif;

#else
      oneof varid = SETUP_DATA.BootModeType,
        questionid = KEY_VALUE_BOOTTYPE_CONFIGURATION,
        prompt = STRING_TOKEN(STR_BOOT_MODE),
        help   = STRING_TOKEN(STR_BOOT_MODE_HELP),
        flags  = INTERACTIVE,
#if FixedPcdGetBool(PcdIsBootTypeDefaultLegacyOS)
//      option text = STRING_TOKEN(STR_ALL),         value = BIOS_BOOT_ALL_OS,    flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_UEFI_ONLY),   value = BIOS_BOOT_UEFI_OS,   flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_LEGACY_ONLY), value = BIOS_BOOT_LEGACY_OS, flags = RESET_REQUIRED| DEFAULT | MANUFACTURING;
#else
//      option text = STRING_TOKEN(STR_ALL),         value = BIOS_BOOT_ALL_OS,    flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_UEFI_ONLY),   value = BIOS_BOOT_UEFI_OS,   flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
        option text = STRING_TOKEN(STR_LEGACY_ONLY), value = BIOS_BOOT_LEGACY_OS, flags = RESET_REQUIRED;
#endif
      endoneof;
#endif


      suppressif  ideqval SETUP_DATA.BootModeType == BIOS_BOOT_LEGACY_OS;
        oneof varid  = SETUP_DATA.ShellEn,
          prompt = STRING_TOKEN(STR_SHELL_ENABLE),
          help   = STRING_TOKEN(STR_SHELL_ENABLE_HELP),
#if FixedPcdGet8(PcdInternalShellDefaultEnable)
          option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
#else
          option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
#endif
        endoneof;
      endif;



      oneof varid  = SETUP_DATA.LanBoot,
        prompt = STRING_TOKEN(STR_OBLAN_BOOT),
        help   = STRING_TOKEN(STR_OBLAN_BOOT_HELP),
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
      endoneof;

      suppressif ideqval SETUP_DATA.LanBoot == 0;

        numeric varid = SETUP_DATA.PxeRetryEn,
          prompt    = STRING_TOKEN(STR_PXE_RETRY_EN),
          help      = STRING_TOKEN(STR_PXE_RETRY_EN_HELP),
          minimum   = 0,
          maximum   = 255,
          step      = 1,
          default   = 0,
        endnumeric;        

      endif;

      suppressif ideqval SETUP_DATA.LanBoot == 0 OR NOT ideqval SETUP_DATA.BootModeType == BIOS_BOOT_UEFI_OS;
        suppressif TRUE;
          oneof varid  = SETUP_DATA.UefiNetworkStack,
            prompt = STRING_TOKEN(STR_UEFI_NETWORK_STACK),
            help   = STRING_TOKEN(STR_UEFI_NETWORK_STACK_HELP),
            option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
            option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          endoneof;
        endif;
      
        suppressif ideqval SETUP_DATA.UefiNetworkStack == 0;
          oneof varid  = SETUP_DATA.NetBootIpVer,
            prompt = STRING_TOKEN(STR_NET_BOOT_IP_VERSION),
            help = STRING_TOKEN(STR_NET_BOOT_IP_VERSION_HELP),
            option text = STRING_TOKEN(STR_ALL_IP), value = NET_BOOT_IP_ALL, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_IPV4),   value = NET_BOOT_IP_V4,  flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
            option text = STRING_TOKEN(STR_IPV6),   value = NET_BOOT_IP_V6,  flags = RESET_REQUIRED;
          endoneof;

        oneof varid  = SETUP_DATA.HttpBootDis,
          prompt = STRING_TOKEN(STR_HTTP_BOOT_EN),
          help   = STRING_TOKEN(STR_HTTP_BOOT_EN_HELP),
#if FixedPcdGet8(PcdHttpBootDefaultEnable)
          option text = STRING_TOKEN(STR_ENABLED),  value = 0, flags = RESET_REQUIRED | DEFAULT;
          option text = STRING_TOKEN(STR_DISABLED), value = 1, flags = RESET_REQUIRED;
#else
          option text = STRING_TOKEN(STR_ENABLED),  value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DISABLED), value = 1, flags = RESET_REQUIRED | DEFAULT;
#endif
        endoneof;
      endif;
      endif;

      suppressif TRUE;
        oneof varid  = SETUP_DATA.NvmeOpRomPriority,
          prompt = STRING_TOKEN(STR_NVME_OPTIONROM_PRIORITY),
          help = STRING_TOKEN(STR_NVME_OPTIONROM_PRIORITY_HELP),
          option text = STRING_TOKEN(STR_BIOS_FIRST),  value = 0, flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
          option text = STRING_TOKEN(STR_ADDON_FIRST), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      subtitle text = STRING_TOKEN(STR_NULL_STRING);

      suppressif FixedPcdGetBool(PcdHideSetupPciOptionRomPostForm);
        goto FORM_OPROM_PRIORITY,
          prompt = STRING_TOKEN(STR_PCI_OPTION_ROM_POST),
          help   = STRING_TOKEN(STR_PCI_OPTION_ROM_POST_HELP);
      endif;

   END_LOGIN_TYPE;

      subtitle text = STRING_TOKEN(STR_NULL_STRING);
      label LABEL_CHANGE_BOOT_ORDER;
      label LABEL_END;
      
  endform;

  form formid = FORM_OPROM_PRIORITY,
      title = STRING_TOKEN(STR_PCI_OPTION_ROM_POST);

      oneof varid  = SETUP_DATA.RomPolicy,
        prompt = STRING_TOKEN(STR_OPROM_PRIORITY),
        help   = STRING_TOKEN(STR_OPROM_PRIORITY),
        option text = STRING_TOKEN(STR_AUTO),   value = 0, flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
        option text = STRING_TOKEN(STR_CUSTOM), value = 1, flags = RESET_REQUIRED;
      endoneof;

      suppressif ideqval SETUP_DATA.RomPolicy == 0;
        oneof varid  = SETUP_DATA.VideoRomPolicy,
          prompt = STRING_TOKEN(STR_VIDEO_ROM_PRIORITY),
          help   = STRING_TOKEN(STR_ROM_PRIORITY_HELP),
          option text = STRING_TOKEN(STR_UEFI_FIRST),   value = ROM_POLICY_UEFI_FIRST,   flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
          option text = STRING_TOKEN(STR_LEGACY_FIRST), value = ROM_POLICY_LEGACY_FIRST, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_NO_LAUNCH),    value = ROM_POLICY_NO_LAUNCH,    flags = RESET_REQUIRED;
        endoneof;

        oneof varid = SETUP_DATA.PxeRomPolicy,
          prompt = STRING_TOKEN(STR_NETWORK_ROM_PRIORITY),
          help   = STRING_TOKEN(STR_ROM_PRIORITY_HELP),
          option text = STRING_TOKEN(STR_UEFI_FIRST),   value = ROM_POLICY_UEFI_FIRST,   flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
          option text = STRING_TOKEN(STR_LEGACY_FIRST), value = ROM_POLICY_LEGACY_FIRST, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_NO_LAUNCH),    value = ROM_POLICY_NO_LAUNCH,    flags = RESET_REQUIRED;
        endoneof;

        oneof varid = SETUP_DATA.StorageRomPolicy,
          prompt = STRING_TOKEN(STR_SATA_ROM_PRIORITY),
          help   = STRING_TOKEN(STR_ROM_PRIORITY_HELP),
          option text = STRING_TOKEN(STR_UEFI_FIRST),   value = ROM_POLICY_UEFI_FIRST,   flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
          option text = STRING_TOKEN(STR_LEGACY_FIRST), value = ROM_POLICY_LEGACY_FIRST, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_NO_LAUNCH),    value = ROM_POLICY_NO_LAUNCH,    flags = RESET_REQUIRED;
        endoneof;

        oneof varid = SETUP_DATA.OtherRomPolicy,
          prompt = STRING_TOKEN(STR_OTHER_ROM_PRIORITY),
          help   = STRING_TOKEN(STR_ROM_PRIORITY_HELP),
          option text = STRING_TOKEN(STR_UEFI_FIRST),   value = ROM_POLICY_UEFI_FIRST,   flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
          option text = STRING_TOKEN(STR_LEGACY_FIRST), value = ROM_POLICY_LEGACY_FIRST, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_NO_LAUNCH),    value = ROM_POLICY_NO_LAUNCH,    flags = RESET_REQUIRED;
        endoneof;

      endif;

      subtitle text = STRING_TOKEN(STR_NULL_STRING);
      subtitle text = STRING_TOKEN(STR_OPROM_PRIORITY_NOTES);

  endform;

endformset;
